<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>The Tezos Developers' Handbook</title>
  </head>
  <body>
    <h1>The Tezos Developers' Handbook</h1>





    <h2>Table of contents</h2>
    <ul>
      <li>
        <a href="#introduction">Introduction</a>
      </li>
      <li>
        <a href="#stack">The Cryptonomic Stack</a>
        <ul>
          <li><a href="#stack-nc">Nautilus Cloud</a></li>
          <li><a href="#stack-conseil">Conseil</a></li>
          <li><a href="#stack-conseiljs">ConseilJS</a></li>
          <li><a href="#stack-galleon">Galleon</a></li>
          <li><a href="#stack-arronax">Arronax</a></li>
          <li><a href="#stack-mininax">Mininax</a></li>
        </ul>
      </li>
      <li>
        <a href="#tutorials">Tutorials</a>
        <ul>
          <li><a href="#tutorials-twentymins">The twenty minute tour</a></li>
          <li><a href="#tutorials-fa1.2">Deploying an FA1.2 fungible token contract</a></li>
          <li><a href="#tutorials-conseil">Analyzing blockchain data using Conseil</a></li>
          <li><a href="#tutorials-bakerregistry">Interacting with the Tezos baker registry</a></li>
        </ul>
      </li>
      <li>
        <a href="#documentation">More Documentation</a>
      </li>
    </ul>
    <hr/>





    <h2><a name="introduction">Introduction</a></h2>
    <p>
      Dear reader, as of early 2020, the <a href="https://developers.tezos.com/">Tezos platform</a> is becoming mature enough that functional and resilient applications can be built with it. <a href="https://cryptonomic.tech/">Cryptonomic</a> has been building tools for Tezos since late 2017 with the intention of creating a seamless end to end experience for Tezos developers. In this handbook, we provide a variety of resources, tutorials and overviews that will help any blockchain developer get up and running quickly with the Tezos platform.
    </p>
    <p>
      The quickest way to become productive is to first read the <a href="#stack">Cryptonomic Stack</a> section followed by the <a href="#tutorials-twentymins">twenty minute tour</a> tutorial. More detailed information about the tools mentioned can be found in the <a href="#documentation">Documentation</a> section. Support is available through <a href="https://matrix.to/#/!rUwpbdwWhWgKINPyOD:cryptonomic.tech">Matrix / Riot</a> and <a href="mailto:support@cryptonomic.tech">email</a>. 
    </p>
    <p>
      This handbook is a living document so it will keep evolving as we add new content, enhance our tools and add new capabilities. Of course, we are also highly receptive to user feedback so expect us to add more content in response to user requests. Speaking of, if you have any ideas for content we should add here, do not hesitate to <a href="https://github.com/Cryptonomic/tezos-developers-handbook/issues">open a GitHub issue</a>.
    </p>
    <hr/>

    <h2><a name="stack">The Cryptonomic Stack</a></h2>
    <p>
      The Cryptonomic stack consists of several tools which are build to work seamlessly together. Odds are if you start working with any one of the tools, the rest will be easy for you to adopt. 
    </p>
    <p>
      The stack is great for fetching and viewing blockchain data, deploying and managing smart contracts, building wallets and visualizations and various kinds of developer tooling.
    </p>
    <p>
      The stack isn't great yet for building user-facing dApps as battle-tested equivalents for MetaMask and other browser plugins are still under development. As we get closer to release for these tools, we will update the documentation here. Maybe you can be the one to build your own tools to make it easy to build Tezos dApps. :)
    </p>
    <h3><a name="stack-nc">Nautilus Cloud</a></h3>
    <p>
      Setting up a development environment for blockchains is notoriously hard. It can be quite arduous and time-consuming to stand up blockchain and indexer nodes. Worry not, we do the hard work so you can focus purely on your work. <a href="https://nautilus.cloud/">Nautilus Cloud</a> provides hosted Tezos and Conseil nodes so you can use them and get started right away. Once your application is ready for production, you can decide how decentralized you want to be and either continue using Nautilus Cloud or stand up your own nodes. 
    </p>
    <p>
      If you are an Ethereum developer, you can simply think of Nautilus Cloud as an equivalent of Infura, except instead of simply offering you blockchain nodes, Nautilus Cloud also offers indexers and others services to make your dApp more powerful and your life much easier.
    </p>
    <h3><a name="stack-conseil">Conseil</a></h3>
    <p>
      Pulling data out of blockchains can also be notoriously difficult. Many developers choose to pull data out of their blockchain nodes and store it in a database for easy querying. This is call indexing. <a href="https://github.com/Cryptonomic/Conseil">Conseil</a> serves as an indexer for the Tezos blockchain. Not only does it provide blockchain data using REST but it also provides metadata to help developers identify and pull the data they need. Nautilus Cloud provides access to Conseil nodes for the major Tezos networks. See the Tutorials section for guides on querying data with Conseil. Conseil is written in the functional style using the <a href="https://scala-lang.org/">Scala</a> programming language.
    </p>
    <p>
      Notable third-party development libraries which integrate with Conseil include <a href="https://github.com/baking-bad/conseilpy">ConseilPy</a> (Python) and <a href="https://github.com/keefertaylor/TezosKit">TezosKit</a> (Swift) and <a href="https://github.com/TezosRio/TezosJ_SDK">TezosJ</a> (Android).
    <h3><a name="stack-conseiljs">ConseilJS</a></h3>
    <p>
      Most front end developers these days like to work with Node libraries. <a href="https://github.com/Cryptonomic/ConseilJS">ConseilJS</a> is an <a href="https://www.npmjs.com/package/conseiljs">NPM library</a> written in TypeScript that allows developers to read from and write to the Tezos blockchain. A variety of applications can be built using ConseilJS. At Cryptonomic, we have used it to build Galleon, Arronax and Mininax, among other projects. ConseilJS is also available as a <a href="https://www.jsdelivr.com/package/npm/conseiljs">standalone JavaScript file</a>. 
    </p>
    <p>
      For Ethereum developers, ConseilJS is a rough analogue of web3.js but supports a greater class of functionalities, including key management, hardware wallet connectivity and blockchain data queries. 
    </p>
    <h3><a name="stack-galleon">Galleon</a></h3>
    <p>
      <a href="https://galleon-wallet.tech">Galleon</a> is a wallet for the Tezos platform. It works equally well with real tez from mainnet and play tez from the major testnet faucets. Developers will find Galleon useful for deploying and invoking smart contracts without writing front end code. This is especially useful if you are simply trying to prototype smart contract code using a tool like <a href="https://smartpy.io">SmartPy</a>. 
    </p>
    <h3><a name="stack-arronax">Arronax</a></h3>
    <p>
      Block explorers can be fairly limiting if you are not a regular wallet users. Blockchain developers need to run rich queries to check on their application's behavior, debug issues and get analytics information about app usage. This is why we created <a href="https://arronax.io/">Arronax</a> (using Conseil as its data provider). Arronax will allow you to run queries and generate reports tailored to your specific needs. It will help you find your top users, find your biggest transactions and most popular smart contract entry points. Go ahead and give <a href="https://arronax.io/">Arronax</a> a spin right now!
    </p>
    <h3><a name="stack-mininax">Mininax</a></h3>
    <p>
      Sometimes you just want to keep things simple and use a good old block explorer. We built <a href="https://mininax.io/">Mininax</a> as a retro mininax explorer serving as an entrypoint into Arronax as a fun summer project using <a href="https://reasonml.github.io/">ReasonML</a>. Now it's evolving into a full-fledged explorer in its own right. Soon, there will be features which will make viewing and investigating smart contracts much more intuitive. 
    </p>
    <hr/>





    <h2><a name="tutorials">Tutorials</a></h2>
    <h3><a name="tutorials-twentymins">The twenty minute tour</a></h3>
    <p>
      In this tutorial, we are going to get a quick taste of the Cryptonomic stack by deploying and examining a simple Tezos smart contract. 
    </p>
    <p>
      If you are not at least mildly familiar with the Cryptonomic stack, it might be worthwhile reading our <a href="#stack">overview</a>. 
    </p>
    <p>
        We need to get access to the blockchain and its data by visiting <a href="https://nautilus.cloud">Nautilus Cloud</a> and logging in with our GitHub account. Once you are logged in you should see something like this:
    </p>
    <img src="images/tutorials-twentymins-nc.png" width="50%" alt="List of servers and keys on Nautilus Cloud">
    <p>
        Nautilus Cloud offers two environments, 'prod' which runs against the Tezos mainnet and 'dev' which runs against a testnet. For each environment, we get the URL to use to access Conseil and Tezos nodes along with the API keys we need to use. In this tutorial, we will be working with a testnet so let's note the URLs and the Conseil API key (in this case 'ab682065-864a-4f11-bc77-0ef4e9493fa1').
    </p>
    <p>
        Now we need to get some testnet funds with which we can originate a contract and play with it. Let's download the <a href="https://galleon-wallet.tech/">Galleon wallet</a> and install it on our system. Once the wallet is up, we'll need to click on 'Settings' on the top right and make the wallet point to the testnet by changing the settings for both the Tezos and Conseil nodes:
    </p>
    <img src="images/tutorials-twentymins-galleon-settings.png" width="50%" alt="The Galleon settings page">
    <p>
        Let's click on "Back to Wallet" and then "Create new Wallet" to get a new wallet going. Pick a file location and provide a strong password as requested. On the next screen, we'll use the "Import Fundraiser Wallet" option to import a free faucet account with tez for us to play with. Visit the <a href="https://faucet.tzalpha.net/">Tezos Faucet</a> and download a JSON document. The document should look something like this:
    </p>
    <pre>        {
            "mnemonic": [
                "avocado",
                "settle",
                "lounge",
                "midnight",
                "frozen",
                "fortune",
                "caution",
                "conduct",
                "turtle",
                "slim",
                "repair",
                "venture",
                "short",
                "idea",
                "dawn"
            ],
            "secret": "774ee65fd9cc68c1368e921fd3c5ef0a9368701e",
            "amount": "17214214921",
            "pkh": "tz1RQS5JmG93Cm3tcg7ciWbVTzNTBQT7Qf99",
            "password": "cmaWby2yF6",
            "email": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3c4d4e57444d484f59125a544b594f4b5d4e7c485946534f1259445d514c505912534e5b">[email&#160;protected]</a>"
            }
    </pre>
    <p>
        Transfer the contents of the JSON document into the Galleon import screen so it looks something like this:
    </p>
    <img src="images/tutorials-twentymins-galleon-import.png" width="50%" alt="Galleon import page">
    <p>
        After you hit the Import button and wait for a couple of minutes, you should see your account address and non-zero tez balance:
    </p>
    <img src="images/tutorials-twentymins-galleon-home.png" width="50%" alt="Galleon home page showing an account with balance">
    <p>
        Not bad! We have 17,214 tez to play with!
    </p>
    <p>
        Now we'll write a very simple Tezos smart contract in SmartPy using the <a href="https://smartpy.io/demo/">online SmartPy IDE</a>. Here is <a href="https://smartpy.io/demo/index.html?code=eJxtkcFOwzAMhu95Cqu7dGKqtCvSJBAScOHEEMfKJO4a0SZV4jGVp8fJ2jImcmmVON_3x7b94AND7DHwMAJGiINSusMY4WV88I4Dai7jUM3_61sFslbwSizV7AMZ@QTrDoAM1lm22NlvZOtdlWsNNVDX6aSuy0hds4EBA_bbiZVW2q5SSalFRE7Yu7lKTca3wSDTtfTUkgONXUfmrLuTtAIIYz1463iJcMzXLwPE6wBSgNV1gKjUCvYUWSUyGlNLCC4d9iQlxb6ldFisVZLko6VH75TM1hFgPoGoyWGwfgPsD8QtBThZbiF6gfkjD0fxojOgW9KfMWPmOyITf8LU81a59EZMjQ1iWHx6GljGSWqwLFIQ50LMd_VWwBezLp6p67w854_7ZieFs@w@BZSOT7EbQUfILYfc8vjP3Wpqf_HkvfkYqViiP1onrHEDJzo_O@OatJtHjQf6w6u@KNhmLIV5NS@Zxi_9Byyk6ko-">the code</a> we are going to use:
    </p>
    <pre>        import smartpy as sp

        class MyContract(sp.Contract):
            # Sets stored string at initialization.
            def __init__(self, param1):
                self.init(contents = param1)

            # Updates stored string when called.
            @sp.entry_point
            def update(self, params):
                self.data.contents = params

        # Test
        @sp.add_test(name = "TheTest")
        def test():
            # We define a test scenario, together with some outputs and checks
            scenario = sp.test_scenario()

            # We first define a contract and add it to the scenario
            c1 = MyContract("Hello")
            scenario += c1

            # And call some of its entry points
            scenario += c1.update("Goodbye")

            # Finally, we check its final storage
            scenario.verify(c1.data.contents == "Goodbye")
    </pre>
    <p>
        This contract simply stores a string. It's given an initial value during origination and it has a function which allows that value to be updated. In the test above, the contract is initialized with "Hello" and is later updated to "World". Very simple! Paste this code into the SmartPy editor and hit the green play button. You should see something like this:
    </p>
    <img src="images/tutorials-twentymins-smartpy-editor.png" width="50%" alt="SmartPy editor showing code">
    <p>
        The SmartPy editor is a great tool for prototyping Tezos smart contracts. Not only is SmartPy an intuitive Python-like language but the editor allows us to write unit tests to validate our functionality. On the right side, we can see the initial state of the contract as well as the effect of each test. Neat! Feel free to play around with SmartPy later to get a sense of the language and all the functionality of the editor.
    </p>
    <p>
        Of course, Michelson is the official language of Tezos smart contracts and our code so far is in SmartPy. Click on the Michelson tab in the editor and then 'Code' to get the Michelson code corresponding to the SmartPy code we just wrote:
    </p>
    <img src="images/tutorials-twentymins-smartpy-michelson.png" width="50%" alt="SmartPy editor showing Michelson">
    <p>
        Now we will use Galleon to deploy this contract and, later, call it once. In Galleon, click on "Interact with Contracts" and then "Deploy a New Contract". Change the format to "Michelson", paste in the code from above, set the initial storage to "Hello", pick a high fee and set the gas and storage limits as shown and deploy the contract:
    </p>
    <img src="images/tutorials-twentymins-galleon-deploy.png" width="50%" alt="Contract deployment with Galleon">
    <p>
      It's a good idea to use high fees on testnets but feel free to choose any appropriate fee during mainnet deployments. After waiting for a couple of minutes, click on the link that shows up and it will direct you to a Mininax page showing details of the origination. Indeed, the initial storage of the deployed contract on the blockchain contains the string "Hello":
    </p>
    <img src="images/tutorials-twentymins-mininax-before.png" width="50%" alt="Viewing an originated contract in Mininax">
    <p>
      Let's invoke the update() function of the smart contract so that the storage contains "Goodbye" instead of "Hello". In Galleon, click on "Interact with contracts" and then "Invoke an Existing Contract". Use the settings shown below:
    </p>
    <img src="images/tutorials-twentymins-galleon-invoke.png" width="50%" alt="Contract invocation with Galleon">
    <p>
      Once again, we'll wait a couple of minutes before clicking on the link that shows up. Mininax now shows the updated storage value!
    </p>
    <img src="images/tutorials-twentymins-mininax-after.png" width="50%" alt="Viewing an invoked contract in Mininax">
    <p>
      Of course, many of us prefer to deploy and interact with contracts programatically instead of using a GUI wallet. Worry not, we have ConseilJS at our disposal! As you can see in <a href="https://gist.github.com/anonymoussprocket/00f673a1188ae5510d50e7c96f6c8a94">this GitHub gist</a>, both the actions above can be done with a few lines of code. As this is a twenty minute tour, we are not going to look at the specific of the code but here are the most relevant bits for your reference:
    </p>
    <pre>      const nodeResult = await TezosNodeWriter.sendContractOriginationOperation(tezosNode, keystore, 0, undefined, fee, '', 1000, 100000, contract, storage, TezosParameterFormat.Michelson);

      const nodeResult = await TezosNodeWriter.sendContractInvocationOperation(tezosNode, keystore, address, 10000, fee, '', freight, gas, entrypoint, parameter, TezosParameterFormat.Michelson);
    </pre>
    <p>
      Observe these lines use the settings we obtained from Nautilus Cloud:
    </p>
    <pre>      const tezosNode = 'https://tezos-dev.cryptonomic-infra.tech:443';
      const conseilServer = { url: 'https://conseil-dev.cryptonomic-infra.tech:443', apiKey: 'ab682065-864a-4f11-bc77-0ef4e9493fa1', network: 'carthagenet' };
    </pre>
    <p>
      Some of the materials in the Documentation section go over the details of contract interaction with ConseilJS.
    </p>
    <p>
      Now for the final step we can run some simple analytics on our contract using Arronax. A <a href="https://arronax.io?e=Tezos%20Carthagenet/operations&q=eyJmaWVsZHMiOlsidGltZXN0YW1wIiwiYmxvY2tfbGV2ZWwiLCJzb3VyY2UiLCJkZXN0aW5hdGlvbiIsImFtb3VudCIsImtpbmQiLCJmZWUiLCJzdGF0dXMiLCJvcGVyYXRpb25fZ3JvdXBfaGFzaCIsInBhcmFtZXRlcnMiXSwicHJlZGljYXRlcyI6W3siZmllbGQiOiJraW5kIiwib3BlcmF0aW9uIjoiZXEiLCJzZXQiOlsidHJhbnNhY3Rpb24iXSwiaW52ZXJzZSI6ZmFsc2V9LHsiZmllbGQiOiJkZXN0aW5hdGlvbiIsIm9wZXJhdGlvbiI6ImVxIiwic2V0IjpbIktUMUVoeU5VeUFVRzQydWRtSnpmQXo3V0RMMmRhRE5iMmN3diJdLCJpbnZlcnNlIjpmYWxzZX1dLCJvcmRlckJ5IjpbeyJmaWVsZCI6InRpbWVzdGFtcCIsImRpcmVjdGlvbiI6ImFzYyJ9XSwiYWdncmVnYXRpb24iOltdLCJsaW1pdCI6MTAwMH0">shared report</a> shows us all the invocations of the contract with address KT1EhyNUyAUG42udmJzfAz7WDL2daDNb2cwv deployed and invoked by the ConseilJS code above. The report should look something like this:
    </p>
    <img src="images/tutorials-twentymins-arronax.png" width="50%" alt="Contract invocations in Arronax">
    <p>
      Observe, at the time this tutorial was last updated, there were four invocations of the contract and a new string was stored each time. Click the Filter button and see how we are specifically looking at transactions sent to KT1EhyNUyAUG42udmJzfAz7WDL2daDNb2cwv. Feel free to click on columns and try different combinations of columns to explore the dataset. Once you deploy your own smart contracts, you can set up a bunch of reports to analyze things like your contract's top callers, the functions used the most and the peak times when your contract is used. Remember, Arronax runs off Conseil so a Conseil query is being submitted each time you run an Arronax report. 
    </p>
    <p>
      So there you have it, a lightening round through the Cryptonomic stack. Don't hesitate to seek help if any of these bits were confusing for you. Check out the Documentation section to get more in depth information about each product. Happy hacking!
    </p>

    <h3><a name="tutorials-fa1.2">Deploying an FA1.2 fungible token contract</a></h3>
    <p>
      The FA1.2 smart contract standard marked a new step in the development possibilities of the Tezos ecosystem by setting specifications for the creation and management of new fugible tokens on the Tezos network. We can now deploy smart contracts to create tokens that can be transferred and exchanged with no loss of value directly on the Tezos blockchain!    </p>
    <p>
      More detailed information on the standard can be found <a href="https://gitlab.com/tzip/tzip/blob/master/proposals/tzip-7/tzip-7.md">here!</a>
    </p>
    <p>
      Using ConseilJS, we can easily deploy and invoke such a contract! Before we start, make sure you have NodeJS and ConseilJS installed. You can run: 
      <pre>       npm i conseiljs</pre> 
      to add our package to your Node project. If you don't have NodeJS, check <a href="https://nodejs.dev">this</a> out for more information on how to get started! We only support Node v12.16.1 which is the current LTS version, so make sure you install NVM (Node Version Manager) to updrade and downgrade Node as needed, which can be found <a href="https://github.com/nvm-sh/nvm">here.</a>
    </p>
    <p>
      First, we need to login to <a href="https://nautilus.cloud/home">Nautilus Cloud</a>. Keep the page handy, we'll need the API keys and node links later. Let's work in TypeScript, and get a fresh .ts file in your NodeJS project. Throw these few lines at the top, they'll handle all of the imports we need for this:
    </p>
    <pre>
      // This imports the FileSystem module which allows us to read files in
      import * as fs from 'fs';                 

      // These lines contain all of the ConseilJS imports needed for our code
      import { TezosConseilClient, TezosWalletUtil, setLogLevel, KeyStore, Tzip7ReferenceTokenHelper } from 'conseiljs';        
      import { ConseilQueryBuilder, ConseilOperator, ConseilDataClient } from 'conseiljs';
    </pre>
    <p>
      Let's set up some constants needed for connecting and deploying to the blockchain. All of this information can be found on Nautilus Cloud! We'll need the URL of a tezos node and the URL of the Conseil Server (along with our API key to gain access). Using these, we can define these constants:
    </p>
    <pre>
      const tezosNode = '...';                                                        // You can get this from Nautilus Cloud, make sure you take the testnet one!
      const conseilServer = { url: '...', apiKey: '...', network: 'carthagenet' };    // Enter both the testnet Conseil Node URL and API Key here!
      const networkBlockTime = 30 + 1;                                                // Because testnet's block time is 30 seconds, we wait 31 seconds before checking for a block update
    </pre>
    <p>
      Make sure your links above go to <strong>port 443</strong>! The URL should end with ':443', if it doesn't, add that to the URL for it to work!
    </p>
    <p>
      Now let's get some funds to play with. Visit the testnet <a href="https://faucet.tzalpha.net/">faucet</a> and <i>download</i> two sets of keys:
    </p>
    <pre>
              {
                "mnemonic": [
                  "right",
                  "bomb",
                  "sea",
                  "paper",
                  "picnic",
                  "wealth",
                  "slush",
                  "hair",
                  "maximum",
                  "tobacco",
                  "ritual",
                  "air",
                  "treat",
                  "inherit",
                  "undo"
                ],
                "secret": "2448de482f7c249ca0d0bb7fb30aa4faa65eb1ef",
                "amount": "2406500031",
                "pkh": "tz1fLQFXALX4pntvRrER21PSQtyaBFYFR7Ut",
                "password": "8mV9AHVZkF",
                "email": "jhconseg.twnylkil@tezos.example.org"
              }
    </pre>
    <p>
      And another one!
    </p>
    <pre>
              {
                "mnemonic": [
                  "crucial",
                  "process",
                  "manage",
                  "more",
                  "damp",
                  "frog",
                  "inside",
                  "reveal",
                  "below",
                  "mandate",
                  "web",
                  "wrist",
                  "grocery",
                  "give",
                  "fitness"
                ],
                "secret": "320f40c4d5b416f58b5e0b099474188e8be7a331",
                "amount": "26523282433",
                "pkh": "tz1UvB93uihSL2ktgePmRrN5C71VMYjAGrWC",
                "password": "GscjPmXhau",
                "email": "cvhrucwz.gkqntnnd@tezos.example.org"
              }
    </pre>
    <p>
      With these accounts ready, we can get started directly in ConseilJS! With the files that we downloaded earlier, we don't need to manually enter data like we did in the previous tutorial. We can import the FileSystem module (imported before as fs) to quickly load and parse the JSON files into an object as seen below. Now, using the TezosWalletUtil, which was imported from ConseilJS, we can feed in the values from the JSON file to initialize the account from the file using the unlockFundraiserIdentity() function.
    </p>
    <pre>
      async function initAccount(account: string): Promise<KeyStore> {
        
        console.log(" ~~ initAccount");
        console.log(`loading ${account} faucet file`);

        const faucetAccount = JSON.parse(fs.readFileSync(`${account}.json`, 'utf8'));

        const keystore = await TezosWalletUtil.unlockFundraiserIdentity(faucetAccount['mnemonic'].join(' '), faucetAccount['email'], faucetAccount['password'], faucetAccount['pkh']);
        console.log(`public key: ${keystore.publicKey}`);
        console.log(`secret key: ${keystore.privateKey}`);
        console.log(`account hash: ${keystore.publicKeyHash}`);

        return keystore;
      }
    </pre>
    <p>
      Moving on, we start getting to the real meat of the code. Let's make an async run function that will handle all of the necessary code:
    </p>
    <pre>
      async function run() {

      }
    </pre>
    <p>
      Inside the function, let's start by setting up some more constants. We need to have a contract originator and issuer, which will come from the two files we downloaded from the faucet. Set these two constants to be the names of the files you downloaded, which also happen to be the account IDs. Eventually, we will pass this string to the initAccount() function we wrote before to set up those accounts. The originator is the account which will deploy the smart contract, while the issuer is the account that will control the issuing of fungible tokens.
    </p>
    <pre>
      const originator = "tz1VXhEA5CiVWeyQP4FomBKTFRC1cmsBWZcY";
      const issuer = "tz1XthtNSi8tdnizeEDULvpzx7mxvverYK4b";
    </pre>
    <p>
      We also need to define some temporary variables, which we will use throughout the code to store outputs and other data. We can store these as follows, and then initialize the originator account, which we'll need to use to originate the contract. We can store its data in the "keystore" variable so we can access it at any time.
    </p>
    <pre>
      let groupid ='';
      let contractAddress = '';
      let mapid = 0;

      let keystore = await initAccount(originator);
    </pre>
    <p>
      Now with all of this set up, let's deploy the contract! ConseilJS has a module called Tzip7ReferenceTokenHelper (referred to henceforth as TokenHelper), which gets its name from the <a href="https://gitlab.com/tzip/tzip/-/tree/master/proposals/tzip-7">TZIP-7 proposal</a> and the <a href="https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-7/ManagedLedger.tz">reference implementation</a> of the token contract in that proposal. The module can be used to deploy and invoke that contract easily! The deployContract() function gives us flexibility to set essential features of the contract, like the supply. We can store the output in a groupid variable to reference the operation later.
    </p>
    <pre>
                                                              //                                                           supply
      groupid = await Tzip7ReferenceTokenHelper.deployContract(tezosNode, keystore, 100_000, keystore.publicKeyHash, true, 0);
    </pre>
    <p>
      We should make sure the operation succeeded, using the awaitOperationConfirmation() method of the the TezosTokenClient class, and passing in the groupid from the previous call. This will return some data about the completed operation, which we can then parse to get the contractAddress.
    </p>
    <pre>
                                                                             //                                              duration   
      let conseilResult = await TezosConseilClient.awaitOperationConfirmation(conseilServer, conseilServer.network, groupid, 5, networkBlockTime);
      contractAddress = conseilResult['originated_contracts'];
    </pre>
    <p>Let's throw in some log statements for good measure to verify that the contract is in the place that we expect using the verifyDestination() function in the TokenHelper module.</p>
    <pre>
      console.log(`deployed token at ${contractAddress} (${groupid})`);

      console.log(`verify: ${await Tzip7ReferenceTokenHelper.verifyDestination(tezosNode, contractAddress)}`);
    </pre>
    <p>
      Now, you might be wondering, "we deployed a contract, but where is it?" The great thing about the TokenHelper is that it has a default token contract that it will deploy and set up! For simple deployments of tokens, this is ideal, and if we want to go back and define a more complex token smart contract, we can easily deploy that as well using ConseilJS!
    </p>
    <p>
      Now that we have a contract deployed, we can collect the storage from that contract to get more specifics about it, like the map ID, which we will need to use later to get data about the contract.
    </p>
    <pre>
      const simplestorage = await Tzip7ReferenceTokenHelper.getSimpleStorage(tezosNode, contractAddress);
      console.log(`simplestorage: ${JSON.stringify(simplestorage, undefined, 2)}`);
      mapid = simplestorage.mapid;
    </pre>
    <p>
      This is all good, we have a contract deployed. But let's say we want to transfer the "ownership" of the contract to a different account. Say, if we coded the contract for someone else, that account should have control. Luckily for us, this is no problem in ConseilJS! Using the setAdministrator() function of the TokenHelper, we can quickly perform this operation.
    </p>
    <pre>
      console.log(`token administrator: ${await Tzip7ReferenceTokenHelper.getAdministrator(tezosNode, contractAddress)}`);
                                                                //                                             fee      gas      freight
      groupid = await Tzip7ReferenceTokenHelper.setAdministrator(tezosNode, keystore, contractAddress, issuer, 100_000, 125_000, 1_000);

      console.log(`token administrator: ${await Tzip7ReferenceTokenHelper.getAdministrator(tezosNode, contractAddress)}`);
    </pre>
    <p>
      Now if we want to perform more contract operations, we need to initialize the issuer account, just as we did before with the originator.
    </p>
    <pre>
      keystore = await initAccount(issuer);
    </pre>
    <p>
      Now the fun begins! With the TokenHelper, we can quickly and easily perform different token actions with the contract we deployed, without having to go through the complex and tedious contract entrypoints. To start, now that we have the issuer set up, we need to activate the ledger, which is the smart contract functionality of making and recording transactions. When we initially deployed the contract, we set it to "paused" instead of "active" so that we could get the contract set up before we run it. Now that it’s ready, we can activate it to use it’s functionality! The following code uses the TokenHelper to activate the contract so we can start calling it, while the surrounding log statements print whether we are active or not.
    </p>
    <pre>
      console.log(`token ${(await Tzip7ReferenceTokenHelper.getPaused(tezosNode, contractAddress) === true) ? 'paused' : 'active' }`);
                                                              //                                     fee     gas      freight
      groupid = await Tzip7ReferenceTokenHelper.activateLedger(tezosNode, keystore, contractAddress, 50_000, 125_000, 100);
      console.log(`token ${(await Tzip7ReferenceTokenHelper.getPaused(tezosNode, contractAddress)) ? 'paused' : 'active' }`);
    </pre>
    <p>
      But now we have an activated ledger without any tokens yet! Once again, TokenHelper comes to the rescue as we can mint new tokens easily using the mint() function. The log statements output the amounts of coin in circulation, while the mint statement we are calling puts a whopping 2 trillion tokens into circulation, US Federal Reserve style.
    </p>
    <pre>
      console.log(`current supply: ${await Tzip7ReferenceTokenHelper.getTokenSupply(tezosNode, contractAddress)}`);
                                                    //                                     fee             amount         gas      freight 
      groupid = await Tzip7ReferenceTokenHelper.mint(tezosNode, keystore, contractAddress, 50_000, issuer, 2_000_000_000_000, 125_000, 100);
      console.log(`new supply: ${await Tzip7ReferenceTokenHelper.getTokenSupply(tezosNode, contractAddress)}`);
      console.log(`${issuer} balance: ${await Tzip7ReferenceTokenHelper.getAccountBalance(tezosNode, mapid, issuer)}`);
    </pre>
    <p>
      Now that we have a billion tokens, let's spread the love and airdrop some to other accounts. Let's start by generating a Conseil Query to get 30 large testnet accounts. We first initialize a blank Query, and then add different fields and predicates to build an increasingly complex query. Just a warning, this script will take a while to run!
    </p>
    <pre>
      let largeAccountQuery = ConseilQueryBuilder.blankQuery();
      largeAccountQuery = ConseilQueryBuilder.addFields(largeAccountQuery, 'account_id');
      largeAccountQuery = ConseilQueryBuilder.addPredicate(largeAccountQuery, 'balance', ConseilOperator.GT, [9000000000]);
      largeAccountQuery = ConseilQueryBuilder.addPredicate(largeAccountQuery, 'account_id', ConseilOperator.STARTSWITH, ['tz']);
      largeAccountQuery = ConseilQueryBuilder.addPredicate(largeAccountQuery, 'account_id', ConseilOperator.IN, [originator, issuer], true);
      largeAccountQuery = ConseilQueryBuilder.setLimit(largeAccountQuery, 30);
      const largeAccountResult = await ConseilDataClient.executeEntityQuery(conseilServer, 'tezos', conseilServer.network, 'accounts', largeAccountQuery);
      const largeAccounts = largeAccountResult.map(a => a.account_id);
    </pre>
    <p>
      Now that we have this data, we can iterate through it, and use a TokenHelper method to transfer the token over to their accounts easily!
    </p>
    <pre>
      for (let i = 0; i < largeAccounts.length; i++) {
                                                                 //                                     fee     source                  destination       amount gas      freight
        groupid = await Tzip7ReferenceTokenHelper.transferBalance(tezosNode, keystore, contractAddress, 50_000, keystore.publicKeyHash, largeAccounts[i], 1_000, 125_000, 100);
        console.log(`balance transfer to "${largeAccounts[i]}"`);
      }
    </pre>
    <p>
      And we've done it! Let's repeat the steps for the 30 smallest accounts.
    </p>
    <pre>
      let smallAccountQuery = ConseilQueryBuilder.blankQuery();
      smallAccountQuery = ConseilQueryBuilder.addFields(smallAccountQuery, 'account_id');
      smallAccountQuery = ConseilQueryBuilder.addPredicate(smallAccountQuery, 'balance', ConseilOperator.LT, [9000000000]);
      smallAccountQuery = ConseilQueryBuilder.addPredicate(smallAccountQuery, 'balance', ConseilOperator.LT, [999000000]);
      smallAccountQuery = ConseilQueryBuilder.addPredicate(smallAccountQuery, 'account_id', ConseilOperator.STARTSWITH, ['tz']);
      smallAccountQuery = ConseilQueryBuilder.addPredicate(smallAccountQuery, 'account_id', ConseilOperator.IN, [originator, issuer], true);
      smallAccountQuery = ConseilQueryBuilder.setLimit(smallAccountQuery, 90);
      let smallAccountResult = await ConseilDataClient.executeEntityQuery(conseilServer, 'tezos', conseilServer.network, 'accounts', smallAccountQuery);
      const smallAccounts = smallAccountResult.map(a => a.account_id);
      console.log(smallAccounts.length);

      for (let i = 0; i < largeAccounts.length; i++) {
          for (let j = 3 * i, k = 3 * (i + 1); j < k; j++) {
              groupid = await Tzip7ReferenceTokenHelper.approveBalance(tezosNode, keystore, contractAddress, 50_000, smallAccounts[j], 100, 125_000, 100);
              console.log(`approve allowance for "${smallAccounts[j]}"`);
          }
      }

      console.log(`current supply: ${await Tzip7ReferenceTokenHelper.getTokenSupply(tezosNode, contractAddress)}`);
      console.log(`${issuer} balance: ${await Tzip7ReferenceTokenHelper.getAccountBalance(tezosNode, mapid, issuer)}`);
    </pre>
    <p>
      Those last two log statements let us find out how many tokens we put into circulation and our (the issuer's) remaining token balance. Isn't creating a currency fun!
    </p>
    <p>
      To look at the code in its entirety, checkout out this <a href="https://gist.github.com/anonymoussprocket/2df333da147b57510b1f78a9c930caab">gist</a> and the corresponding Medium <a href="https://medium.com/the-cryptonomic-aperiodical/tezos-is-now-an-asset-tokenization-platform-4d88ded4e9c">article</a>. Once again, feel free to reach out for any assistance whatsoever, and see our Documentation for a more in-depth look at the products used. Happy Hacking!
    </p>
    <h3><a name="tutorials-conseil">Analyzing blockchain data using Conseil</a></h3>
    <p>
      Visit the <a href="https://github.com/Cryptonomic/Conseil/wiki/Tutorial%3A-Querying-for-Tezos-data">tutorial</a> on the Conseil wiki.
    </p>
    <h3><a name="tutorials-bakerregistry">Interacting with the Tezos baker registry</a></h3>
    <p>
      Coming soon...
    </p>
    <hr/>
    




    <h2><a name="documentation">More Documentation</a></h2>

    <p>Coming very soon!</p>
    
  <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body>
</html>
