<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>The Tezos Developers' Handbook</title>
  </head>
  <body>
    <h1>The Tezos Developers' Handbook</h1>





    <h2>Table of contents</h2>
    <ul>
      <li>
        <a href="#introduction">Introduction</a>
      </li>
      <li>
        <a href="#stack">The Cryptonomic Stack</a>
        <ul>
          <li><a href="#stack-nc">Nautilus Cloud</a></li>
          <li><a href="#stack-conseil">Conseil</a></li>
          <li><a href="#stack-conseiljs">ConseilJS</a></li>
          <li><a href="#stack-galleon">Galleon</a></li>
          <li><a href="#stack-arronax">Arronax</a></li>
          <li><a href="#stack-mininax">Mininax</a></li>
        </ul>
      </li>
      <li>
        <a href="#tutorials">Tutorials</a>
        <ul>
          <li><a href="#tutorials-twentymins">The twenty minute tour</a></li>
          <li><a href="#tutorials-fa1.2">Deploying an FA1.2 fungible token contract</a></li>
          <li><a href="#tutorials-conseil">Analyzing blockchain data using Conseil</a></li>
          <li><a href="#tutorials-conseiljs">Basic blockchain functions with ConseilJS</a></li>
          <li><a href="#tutorials-bakerregistry">Interacting with the Tezos baker registry</a></li>
        </ul>
      </li>
      <li>
        <a href="#documentation">More Documentation</a>
      </li>
    </ul>
    <hr/>





    <h2><a name="introduction">Introduction</a></h2>
    <p>
      Dear reader, as of early 2020, the <a href="https://developers.tezos.com/">Tezos platform</a> is becoming mature enough that functional and resilient applications can be built with it. <a href="https://cryptonomic.tech/">Cryptonomic</a> has been building tools for Tezos since late 2017 with the intention of creating a seamless end to end experience for Tezos developers. In this handbook, we provide a variety of resources, tutorials and overviews that will help any blockchain developer get up and running quickly with the Tezos platform.
    </p>
    <p>
      The quickest way to become productive is to first read the <a href="#stack">Cryptonomic Stack</a> section followed by the <a href="#tutorials-twentymins">twenty minute tour</a> tutorial. More detailed information about the tools mentioned can be found in the <a href="#documentation">Documentation</a> section. Support is available through <a href="https://matrix.to/#/!rUwpbdwWhWgKINPyOD:cryptonomic.tech">Matrix / Riot</a> and <a href="mailto:support@cryptonomic.tech">email</a>. 
    </p>
    <p>
      This handbook is a living document so it will keep evolving as we add new content, enhance our tools and add new capabilities. Of course, we are also highly receptive to user feedback so expect us to add more content in response to user requests. Speaking of, if you have any ideas for content we should add here, do not hesitate to <a href="https://github.com/Cryptonomic/tezos-developers-handbook/issues">open a GitHub issue</a>.
    </p>
    <hr/>

    <h2><a name="stack">The Cryptonomic Stack</a></h2>
    <p>
      The Cryptonomic stack consists of several tools which are build to work seamlessly together. Odds are if you start working with any one of the tools, the rest will be easy for you to adopt. 
    </p>
    <p>
      The stack is great for fetching and viewing blockchain data, deploying and managing smart contracts, building wallets and visualizations and various kinds of developer tooling.
    </p>
    <p>
      The stack isn't great yet for building user-facing dApps as battle-tested equivalents for MetaMask and other browser plugins are still under development. As we get closer to release for these tools, we will update the documentation here. Maybe you can be the one to build your own tools to make it easy to build Tezos dApps. :)
    </p>
    <h3><a name="stack-nc">Nautilus Cloud</a></h3>
    <p>
      Setting up a development environment for blockchains is notoriously hard. It can be quite arduous and time-consuming to stand up blockchain and indexer nodes. Worry not, we do the hard work so you can focus purely on your work. <a href="https://nautilus.cloud/">Nautilus Cloud</a> provides hosted Tezos and Conseil nodes so you can use them and get started right away. Once your application is ready for production, you can decide how decentralized you want to be and either continue using Nautilus Cloud or stand up your own nodes. 
    </p>
    <p>
      If you are an Ethereum developer, you can simply think of Nautilus Cloud as an equivalent of Infura, except instead of simply offering you blockchain nodes, Nautilus Cloud also offers indexers and others services to make your dApp more powerful and your life much easier.
    </p>
    <h3><a name="stack-conseil">Conseil</a></h3>
    <p>
      Pulling data out of blockchains can also be notoriously difficult. Many developers choose to pull data out of their blockchain nodes and store it in a database for easy querying. This is call indexing. <a href="https://github.com/Cryptonomic/Conseil">Conseil</a> serves as an indexer for the Tezos blockchain. Not only does it provide blockchain data using REST but it also provides metadata to help developers identify and pull the data they need. Nautilus Cloud provides access to Conseil nodes for the major Tezos networks. See the Tutorials section for guides on querying data with Conseil. Conseil is written in the functional style using the <a href="https://scala-lang.org/">Scala</a> programming language.
    </p>
    <p>
      Notable third-party development libraries which integrate with Conseil include <a href="https://github.com/baking-bad/conseilpy">ConseilPy</a> (Python) and <a href="https://github.com/keefertaylor/TezosKit">TezosKit</a> (Swift) and <a href="https://github.com/TezosRio/TezosJ_SDK">TezosJ</a> (Android).
    <h3><a name="stack-conseiljs">ConseilJS</a></h3>
    <p>
      Most front end developers these days like to work with Node libraries. <a href="https://github.com/Cryptonomic/ConseilJS">ConseilJS</a> is an <a href="https://www.npmjs.com/package/conseiljs">NPM library</a> written in TypeScript that allows developers to read from and write to the Tezos blockchain. A variety of applications can be built using ConseilJS. At Cryptonomic, we have used it to build Galleon, Arronax and Mininax, among other projects. ConseilJS is also available as a <a href="https://www.jsdelivr.com/package/npm/conseiljs">standalone JavaScript file</a>. 
    </p>
    <p>
      For Ethereum developers, ConseilJS is a rough analogue of web3.js but supports a greater class of functionalities, including key management, hardware wallet connectivity and blockchain data queries. 
    </p>
    <h3><a name="stack-galleon">Galleon</a></h3>
    <p>
      <a href="https://galleon-wallet.tech">Galleon</a> is a wallet for the Tezos platform. It works equally well with real tez from mainnet and play tez from the major testnet faucets. Developers will find Galleon useful for deploying and invoking smart contracts without writing front end code. This is especially useful if you are simply trying to prototype smart contract code using a tool like <a href="https://smartpy.io">SmartPy</a>. 
    </p>
    <h3><a name="stack-arronax">Arronax</a></h3>
    <p>
      Block explorers can be fairly limiting if you are not a regular wallet users. Blockchain developers need to run rich queries to check on their application's behavior, debug issues and get analytics information about app usage. This is why we created <a href="https://arronax.io/">Arronax</a> (using Conseil as its data provider). Arronax will allow you to run queries and generate reports tailored to your specific needs. It will help you find your top users, find your biggest transactions and most popular smart contract entry points. Go ahead and give <a href="https://arronax.io/">Arronax</a> a spin right now!
    </p>
    <h3><a name="stack-mininax">Mininax</a></h3>
    <p>
      Sometimes you just want to keep things simple and use a good old block explorer. We built <a href="https://mininax.io/">Mininax</a> as a retro mininax explorer serving as an entrypoint into Arronax as a fun summer project using <a href="https://reasonml.github.io/">ReasonML</a>. Now it's evolving into a full-fledged explorer in its own right. Soon, there will be features which will make viewing and investigating smart contracts much more intuitive. 
    </p>
    <hr/>





    <h2><a name="tutorials">Tutorials</a></h2>
    <h3><a name="tutorials-twentymins">The twenty minute tour</a></h3>
    <p>
      In this tutorial, we are going to get a quick taste of the Cryptonomic stack by deploying and examining a simple Tezos smart contract. 
    </p>
    <p>
      If you are not at least mildly familiar with the Cryptonomic stack, it might be worthwhile reading our <a href="#stack">overview</a>. 
    </p>
    <p>
        We need to get access to the blockchain and its data by visiting <a href="https://nautilus.cloud">Nautilus Cloud</a> and logging in with our GitHub account. Once you are logged in you should see something like this:
    </p>
    <img src="images/tutorials-twentymins-nc.png" width="50%" alt="List of servers and keys on Nautilus Cloud">
    <p>
        Nautilus Cloud offers two environments, 'prod' which runs against the Tezos mainnet and 'dev' which runs against a testnet. For each environment, we get the URL to use to access Conseil and Tezos nodes along with the API keys we need to use. In this tutorial, we will be working with a testnet so let's note the URLs and the Conseil API key (in this case 'ab682065-864a-4f11-bc77-0ef4e9493fa1').
    </p>
    <p>
        Now we need to get some testnet funds with which we can originate a contract and play with it. Let's download the <a href="https://galleon-wallet.tech/">Galleon wallet</a> and install it on our system. Once the wallet is up, we'll need to click on 'Settings' on the top right and make the wallet point to the testnet by changing the settings for both the Tezos and Conseil nodes:
    </p>
    <img src="images/tutorials-twentymins-galleon-settings.png" width="50%" alt="The Galleon settings page">
    <p>
        Let's click on "Back to Wallet" and then "Create new Wallet" to get a new wallet going. Pick a file location and provide a strong password as requested. On the next screen, we'll use the "Import Fundraiser Wallet" option to import a free faucet account with tez for us to play with. Visit the <a href="https://faucet.tzalpha.net/">Tezos Faucet</a> and download a JSON document. The document should look something like this:
    </p>
    <pre>        {
            "mnemonic": [
                "avocado",
                "settle",
                "lounge",
                "midnight",
                "frozen",
                "fortune",
                "caution",
                "conduct",
                "turtle",
                "slim",
                "repair",
                "venture",
                "short",
                "idea",
                "dawn"
            ],
            "secret": "774ee65fd9cc68c1368e921fd3c5ef0a9368701e",
            "amount": "17214214921",
            "pkh": "tz1RQS5JmG93Cm3tcg7ciWbVTzNTBQT7Qf99",
            "password": "cmaWby2yF6",
            "email": "qrkxqtse.fhweswar@tezos.example.org"
            }
    </pre>
    <p>
        Transfer the contents of the JSON document into the Galleon import screen so it looks something like this:
    </p>
    <img src="images/tutorials-twentymins-galleon-import.png" width="50%" alt="Galleon import page">
    <p>
    Please copy paste  the contents of the list in the 15 word input asked at the start.Further paste the fundraiser email and fundraiser password in email and password respectively.You should paste the secret key in the activation key and pkh in the publc key hash inputfields respectively.
    </p>
    <p>
        After you hit the Import button and wait for a couple of minutes, you should see your account address and non-zero tez balance:
    </p>
    <img src="images/tutorials-twentymins-galleon-home.png" width="50%" alt="Galleon home page showing an account with balance">
    <p>
        Not bad! We have 17,214 tez to play with!
    </p>
    <p>
        Now we'll write a very simple Tezos smart contract in SmartPy using the <a href="https://smartpy.io/demo/">online SmartPy IDE</a>. Here is <a href="https://smartpy.io/demo/index.html?code=eJxtkcFOwzAMhu95Cqu7dGKqtCvSJBAScOHEEMfKJO4a0SZV4jGVp8fJ2jImcmmVON_3x7b94AND7DHwMAJGiINSusMY4WV88I4Dai7jUM3_61sFslbwSizV7AMZ@QTrDoAM1lm22NlvZOtdlWsNNVDX6aSuy0hds4EBA_bbiZVW2q5SSalFRE7Yu7lKTca3wSDTtfTUkgONXUfmrLuTtAIIYz1463iJcMzXLwPE6wBSgNV1gKjUCvYUWSUyGlNLCC4d9iQlxb6ldFisVZLko6VH75TM1hFgPoGoyWGwfgPsD8QtBThZbiF6gfkjD0fxojOgW9KfMWPmOyITf8LU81a59EZMjQ1iWHx6GljGSWqwLFIQ50LMd_VWwBezLp6p67w854_7ZieFs@w@BZSOT7EbQUfILYfc8vjP3Wpqf_HkvfkYqViiP1onrHEDJzo_O@OatJtHjQf6w6u@KNhmLIV5NS@Zxi_9Byyk6ko-">the code</a> we are going to use:
    </p>
    <pre>        
        import smartpy as sp

        class MyContract(sp.Contract):
            # Sets stored string at initialization.
            def __init__(self, param1):
                self.init(contents = param1)

            # Updates stored string when called.
            @sp.entry_point
            def update(self, params):
                self.data.contents = params

        # Test
        @sp.add_test(name = "TheTest")
        def test():
            # We define a test scenario, together with some outputs and checks
            scenario = sp.test_scenario()

            # We first define a contract and add it to the scenario
            c1 = MyContract("Hello")
            scenario += c1

            # And call some of its entry points
            scenario += c1.update("Goodbye")

            # Finally, we check its final storage
            scenario.verify(c1.data.contents == "Goodbye")
    </pre>
    <p>
        This contract simply stores a string. It's given an initial value during origination and it has a function which allows that value to be updated. In the test above, the contract is initialized with "Hello" and is later updated to "World". Very simple! Paste this code into the SmartPy editor and hit the green play button. You should see something like this:
    </p>
    <img src="images/tutorials-twentymins-smartpy-editor.png" width="50%" alt="SmartPy editor showing code">
    <p>
        The SmartPy editor is a great tool for prototyping Tezos smart contracts. Not only is SmartPy an intuitive Python-like language but the editor allows us to write unit tests to validate our functionality. On the right side, we can see the initial state of the contract as well as the effect of each test. Neat! Feel free to play around with SmartPy later to get a sense of the language and all the functionality of the editor.
    </p>
    <p>
        Of course, Michelson is the official language of Tezos smart contracts and our code so far is in SmartPy. Click on the Michelson tab in the editor and then 'Code' to get the Michelson code corresponding to the SmartPy code we just wrote:
    </p>
    <img src="images/tutorials-twentymins-smartpy-michelson.png" width="50%" alt="SmartPy editor showing Michelson">
    <p>
        Now we will use Galleon to deploy this contract and, later, call it once. In Galleon, click on "Interact with Contracts" and then "Deploy a New Contract". Change the format to "Michelson", paste in the code from above, set the initial storage to "Hello", pick a high fee and set the gas and storage limits as shown and deploy the contract:
    </p>
    <img src="images/tutorials-twentymins-galleon-deploy.png" width="50%" alt="Contract deployment with Galleon">
    <p>
      It's a good idea to use high fees on testnets but feel free to choose any appropriate fee during mainnet deployments. After waiting for a couple of minutes, click on the link that shows up and it will direct you to a Mininax page showing details of the origination. Indeed, the initial storage of the deployed contract on the blockchain contains the string "Hello":
    </p>
    <img src="images/tutorials-twentymins-mininax-before.png" width="50%" alt="Viewing an originated contract in Mininax">
    <p>
      Let's invoke the update() function of the smart contract so that the storage contains "Goodbye" instead of "Hello". In Galleon, click on "Interact with contracts" and then "Invoke an Existing Contract". Use the settings shown below:
    </p>
    <img src="images/tutorials-twentymins-galleon-invoke.png" width="50%" alt="Contract invocation with Galleon">
    <p>
      Once again, we'll wait a couple of minutes before clicking on the link that shows up. Mininax now shows the updated storage value!
    </p>
    <img src="images/tutorials-twentymins-mininax-after.png" width="50%" alt="Viewing an invoked contract in Mininax">
    <p>
      Of course, many of us prefer to deploy and interact with contracts programatically instead of using a GUI wallet. Worry not, we have ConseilJS at our disposal! As you can see in <a href="https://gist.github.com/anonymoussprocket/00f673a1188ae5510d50e7c96f6c8a94">this GitHub gist</a>, both the actions above can be done with a few lines of code. As this is a twenty minute tour, we are not going to look at the specific of the code but here are the most relevant bits for your reference:
    </p>
    <pre>      
      const nodeResult = await TezosNodeWriter.sendContractOriginationOperation(tezosNode, keystore, 0, undefined, fee, '', 1000, 100000, contract, storage, TezosParameterFormat.Michelson);

      const nodeResult = await TezosNodeWriter.sendContractInvocationOperation(tezosNode, keystore, address, 10000, fee, '', freight, gas, entrypoint, parameter, TezosParameterFormat.Michelson);
    </pre>
    <p>
      Observe these lines use the settings we obtained from Nautilus Cloud:
    </p>
    <pre>      
      const tezosNode = 'https://tezos-dev.cryptonomic-infra.tech:443';
      const conseilServer = { url: 'https://conseil-dev.cryptonomic-infra.tech:443', apiKey: 'ab682065-864a-4f11-bc77-0ef4e9493fa1', network: 'carthagenet' };
    </pre>
    <p>
      Some of the materials in the Documentation section go over the details of contract interaction with ConseilJS.
    </p>
    <p>
      Now for the final step we can run some simple analytics on our contract using Arronax. A <a href="https://arronax.io?e=Tezos%20Carthagenet/operations&q=eyJmaWVsZHMiOlsidGltZXN0YW1wIiwiYmxvY2tfbGV2ZWwiLCJzb3VyY2UiLCJkZXN0aW5hdGlvbiIsImFtb3VudCIsImtpbmQiLCJmZWUiLCJzdGF0dXMiLCJvcGVyYXRpb25fZ3JvdXBfaGFzaCIsInBhcmFtZXRlcnMiXSwicHJlZGljYXRlcyI6W3siZmllbGQiOiJraW5kIiwib3BlcmF0aW9uIjoiZXEiLCJzZXQiOlsidHJhbnNhY3Rpb24iXSwiaW52ZXJzZSI6ZmFsc2V9LHsiZmllbGQiOiJkZXN0aW5hdGlvbiIsIm9wZXJhdGlvbiI6ImVxIiwic2V0IjpbIktUMUVoeU5VeUFVRzQydWRtSnpmQXo3V0RMMmRhRE5iMmN3diJdLCJpbnZlcnNlIjpmYWxzZX1dLCJvcmRlckJ5IjpbeyJmaWVsZCI6InRpbWVzdGFtcCIsImRpcmVjdGlvbiI6ImFzYyJ9XSwiYWdncmVnYXRpb24iOltdLCJsaW1pdCI6MTAwMH0">shared report</a> shows us all the invocations of the contract with address KT1EhyNUyAUG42udmJzfAz7WDL2daDNb2cwv deployed and invoked by the ConseilJS code above. The report should look something like this:
    </p>
    <img src="images/tutorials-twentymins-arronax.png" width="50%" alt="Contract invocations in Arronax">
    <p>
      Observe, at the time this tutorial was last updated, there were four invocations of the contract and a new string was stored each time. Click the Filter button and see how we are specifically looking at transactions sent to KT1EhyNUyAUG42udmJzfAz7WDL2daDNb2cwv. Feel free to click on columns and try different combinations of columns to explore the dataset. Once you deploy your own smart contracts, you can set up a bunch of reports to analyze things like your contract's top callers, the functions used the most and the peak times when your contract is used. Remember, Arronax runs off Conseil so a Conseil query is being submitted each time you run an Arronax report. 
    </p>
    <p>
      So there you have it, a lightening round through the Cryptonomic stack. Don't hesitate to seek help if any of these bits were confusing for you. Check out the Documentation section to get more in depth information about each product. Happy hacking!
    </p>

    <h3><a name="tutorials-fa1.2">Deploying an FA1.2 fungible token contract</a></h3>
    <p>
      The FA1.2 smart contract standard marked a new step in the development possibilities of the Tezos ecosystem by setting specifications for the creation and management of new fugible tokens on the Tezos network. 
    </p>
    <p>
      We can now deploy smart contracts to create tokens that can be transferred and exchanged with no loss of value directly on the Tezos blockchain!    </p>
    <p>
      More detailed information on the standard can be found <a href="https://gitlab.com/tzip/tzip/blob/master/proposals/tzip-7/tzip-7.md">here!</a>
    </p>
    <p>
      Using ConseilJS, we can easily deploy and invoke such a contract! Before we start, make sure you have NodeJS and ConseilJS installed. You can run: 
      <pre>       npm i conseiljs</pre> 
      to add our package to your Node project. If you don't have NodeJS, check <a href="https://nodejs.dev">this</a> out for more information on how to get started! We only support Node v12.16.1 which is the current LTS version, so make sure you install NVM (Node Version Manager) to updrade and downgrade Node as needed, which can be found <a href="https://github.com/nvm-sh/nvm">here.</a>
    </p>
    <p>
      First, we need to login to <a href="https://nautilus.cloud/home">Nautilus Cloud</a>. Keep the page handy, we'll need the API keys and node links later. Let's work in TypeScript, and get a fresh .ts file in your NodeJS project. Throw these few lines at the top, they'll handle all of the imports we need for this:
    </p>
    <pre>
      // This imports the FileSystem module which allows us to read files in
      import * as fs from 'fs';                 

      // These lines contain all of the ConseilJS imports needed for our code
      import { TezosConseilClient, TezosWalletUtil, setLogLevel, KeyStore, Tzip7ReferenceTokenHelper } from 'conseiljs';        
      import { ConseilQueryBuilder, ConseilOperator, ConseilDataClient } from 'conseiljs';
    </pre>
    <p>
      Let's set up some constants needed for connecting and deploying to the blockchain. All of this information can be found on Nautilus Cloud! We'll need the URL of a tezos node and the URL of the Conseil Server (along with our API key to gain access). Using these, we can define these constants:
    </p>
    <pre>
      const tezosNode = '...';                                                        // You can get this from Nautilus Cloud, make sure you take the testnet one!
      const conseilServer = { url: '...', apiKey: '...', network: 'carthagenet' };    // Enter both the testnet Conseil Node URL and API Key here!
      const networkBlockTime = 30 + 1;                                                // Because testnet's block time is 30 seconds, we wait 31 seconds before checking for a block update
    </pre>
    <p>
      Make sure your links above go to <strong>port 443</strong>! The URL should end with ':443', if it doesn't, add that to the URL for it to work!
    </p>
    <p>
      Now let's get some funds to play with. Visit the testnet <a href="https://faucet.tzalpha.net/">faucet</a> and <i>download</i> two sets of keys:
    </p>
    <pre>
              {
                "mnemonic": [
                  "right",
                  "bomb",
                  "sea",
                  "paper",
                  "picnic",
                  "wealth",
                  "slush",
                  "hair",
                  "maximum",
                  "tobacco",
                  "ritual",
                  "air",
                  "treat",
                  "inherit",
                  "undo"
                ],
                "secret": "2448de482f7c249ca0d0bb7fb30aa4faa65eb1ef",
                "amount": "2406500031",
                "pkh": "tz1fLQFXALX4pntvRrER21PSQtyaBFYFR7Ut",
                "password": "8mV9AHVZkF",
                "email": "jhconseg.twnylkil@tezos.example.org"
              }
    </pre>
    <p>
      And another one!
    </p>
    <pre>
              {
                "mnemonic": [
                  "crucial",
                  "process",
                  "manage",
                  "more",
                  "damp",
                  "frog",
                  "inside",
                  "reveal",
                  "below",
                  "mandate",
                  "web",
                  "wrist",
                  "grocery",
                  "give",
                  "fitness"
                ],
                "secret": "320f40c4d5b416f58b5e0b099474188e8be7a331",
                "amount": "26523282433",
                "pkh": "tz1UvB93uihSL2ktgePmRrN5C71VMYjAGrWC",
                "password": "GscjPmXhau",
                "email": "cvhrucwz.gkqntnnd@tezos.example.org"
              }
    </pre>
    <p>
      With these accounts ready, we can get started directly in ConseilJS! With the files that we downloaded earlier, we don't need to manually enter data like we did in the previous tutorial. We can import the FileSystem module (imported before as fs) to quickly load and parse the JSON files into an object as seen below. Now, using the TezosWalletUtil, which was imported from ConseilJS, we can feed in the values from the JSON file to initialize the account from the file using the unlockFundraiserIdentity() function.
    </p>
    <pre>
      async function initAccount(account: string): Promise<KeyStore> {
        
        console.log(" ~~ initAccount");
        console.log(`loading ${account} faucet file`);

        const faucetAccount = JSON.parse(fs.readFileSync(`${account}.json`, 'utf8'));

        const keystore = await TezosWalletUtil.unlockFundraiserIdentity(faucetAccount['mnemonic'].join(' '), faucetAccount['email'], faucetAccount['password'], faucetAccount['pkh']);
        console.log(`public key: ${keystore.publicKey}`);
        console.log(`secret key: ${keystore.privateKey}`);
        console.log(`account hash: ${keystore.publicKeyHash}`);

        return keystore;
      }
    </pre>
    <p>
      Moving on, we start getting to the real meat of the code. Let's make an async run function that will handle all of the necessary code:
    </p>
    <pre>
      async function run() {

      }
    </pre>
    <p>
      Inside the function, let's start by setting up some more constants. We need to have a contract originator and issuer, which will come from the two files we downloaded from the faucet. Set these two constants to be the names of the files you downloaded, which also happen to be the account IDs. Eventually, we will pass this string to the initAccount() function we wrote before to set up those accounts. The originator is the account which will deploy the smart contract, while the issuer is the account that will control the issuing of fungible tokens.
    </p>
    <pre>
      const originator = "tz1VXhEA5CiVWeyQP4FomBKTFRC1cmsBWZcY";
      const issuer = "tz1XthtNSi8tdnizeEDULvpzx7mxvverYK4b";
    </pre>
    <p>
      We also need to define some temporary variables, which we will use throughout the code to store outputs and other data. We can store these as follows, and then initialize the originator account, which we'll need to use to originate the contract. We can store its data in the "keystore" variable so we can access it at any time.
    </p>
    <pre>
      let groupid ='';
      let contractAddress = '';
      let mapid = 0;

      let keystore = await initAccount(originator);
    </pre>
    <p>
      Now with all of this set up, let's deploy the contract! ConseilJS has a module called Tzip7ReferenceTokenHelper (referred to henceforth as TokenHelper), which gets its name from the <a href="https://gitlab.com/tzip/tzip/-/tree/master/proposals/tzip-7">TZIP-7 proposal</a> and the <a href="https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-7/ManagedLedger.tz">reference implementation</a> of the token contract in that proposal. The module can be used to deploy and invoke that contract easily! The deployContract() function gives us flexibility to set essential features of the contract, like the supply. We can store the output in a groupid variable to reference the operation later.
    </p>
    <pre>
                                                              //                                                           supply
      groupid = await Tzip7ReferenceTokenHelper.deployContract(tezosNode, keystore, 100_000, keystore.publicKeyHash, true, 0);
    </pre>
    <p>
      We should make sure the operation succeeded, using the awaitOperationConfirmation() method of the the TezosTokenClient class, and passing in the groupid from the previous call. This will return some data about the completed operation, which we can then parse to get the contractAddress.
    </p>
    <pre>
                                                                             //                                              duration   
      let conseilResult = await TezosConseilClient.awaitOperationConfirmation(conseilServer, conseilServer.network, groupid, 5, networkBlockTime);
      contractAddress = conseilResult['originated_contracts'];
    </pre>
    <p>Let's throw in some log statements for good measure to verify that the contract is in the place that we expect using the verifyDestination() function in the TokenHelper module.</p>
    <pre>
      console.log(`deployed token at ${contractAddress} (${groupid})`);

      console.log(`verify: ${await Tzip7ReferenceTokenHelper.verifyDestination(tezosNode, contractAddress)}`);
    </pre>
    <p>
      Now, you might be wondering, "we deployed a contract, but where is it?" The great thing about the TokenHelper is that it has a default token contract that it will deploy and set up! For simple deployments of tokens, this is ideal, and if we want to go back and define a more complex token smart contract, we can easily deploy that as well using ConseilJS!
    </p>
    <p>
      Now that we have a contract deployed, we can collect the storage from that contract to get more specifics about it, like the map ID, which we will need to use later to get data about the contract.
    </p>
    <pre>
      const simplestorage = await Tzip7ReferenceTokenHelper.getSimpleStorage(tezosNode, contractAddress);
      console.log(`simplestorage: ${JSON.stringify(simplestorage, undefined, 2)}`);
      mapid = simplestorage.mapid;
    </pre>
    <p>
      This is all good, we have a contract deployed. But let's say we want to transfer the "ownership" of the contract to a different account. Say, if we coded the contract for someone else, that account should have control. Luckily for us, this is no problem in ConseilJS! Using the setAdministrator() function of the TokenHelper, we can quickly perform this operation.
    </p>
    <pre>
      console.log(`token administrator: ${await Tzip7ReferenceTokenHelper.getAdministrator(tezosNode, contractAddress)}`);
                                                                //                                             fee      gas      freight
      groupid = await Tzip7ReferenceTokenHelper.setAdministrator(tezosNode, keystore, contractAddress, issuer, 100_000, 125_000, 1_000);

      console.log(`token administrator: ${await Tzip7ReferenceTokenHelper.getAdministrator(tezosNode, contractAddress)}`);
    </pre>
    <p>
      Now if we want to perform more contract operations, we need to initialize the issuer account, just as we did before with the originator.
    </p>
    <pre>
      keystore = await initAccount(issuer);
    </pre>
    <p>
      Now the fun begins! With the TokenHelper, we can quickly and easily perform different token actions with the contract we deployed, without having to go through the complex and tedious contract entrypoints. To start, now that we have the issuer set up, we need to activate the ledger, which is the smart contract functionality of making and recording transactions. When we initially deployed the contract, we set it to "paused" instead of "active" so that we could get the contract set up before we run it. Now that it’s ready, we can activate it to use it’s functionality! The following code uses the TokenHelper to activate the contract so we can start calling it, while the surrounding log statements print whether we are active or not.
    </p>
    <pre>
      console.log(`token ${(await Tzip7ReferenceTokenHelper.getPaused(tezosNode, contractAddress) === true) ? 'paused' : 'active' }`);
                                                              //                                     fee     gas      freight
      groupid = await Tzip7ReferenceTokenHelper.activateLedger(tezosNode, keystore, contractAddress, 50_000, 125_000, 100);
      console.log(`token ${(await Tzip7ReferenceTokenHelper.getPaused(tezosNode, contractAddress)) ? 'paused' : 'active' }`);
    </pre>
    <p>
      But now we have an activated ledger without any tokens yet! Once again, TokenHelper comes to the rescue as we can mint new tokens easily using the mint() function. The log statements output the amounts of coin in circulation, while the mint statement we are calling puts a whopping 2 trillion tokens into circulation, US Federal Reserve style.
    </p>
    <pre>
      console.log(`current supply: ${await Tzip7ReferenceTokenHelper.getTokenSupply(tezosNode, contractAddress)}`);
                                                    //                                     fee             amount         gas      freight 
      groupid = await Tzip7ReferenceTokenHelper.mint(tezosNode, keystore, contractAddress, 50_000, issuer, 2_000_000_000_000, 125_000, 100);
      console.log(`new supply: ${await Tzip7ReferenceTokenHelper.getTokenSupply(tezosNode, contractAddress)}`);
      console.log(`${issuer} balance: ${await Tzip7ReferenceTokenHelper.getAccountBalance(tezosNode, mapid, issuer)}`);
    </pre>
    <p>
      Now that we have a billion tokens, let's spread the love and airdrop some to other accounts. Let's start by generating a Conseil Query to get 30 large testnet accounts. We first initialize a blank Query, and then add different fields and predicates to build an increasingly complex query. Just a warning, this script will take a while to run!
    </p>
    <pre>
      let largeAccountQuery = ConseilQueryBuilder.blankQuery();
      largeAccountQuery = ConseilQueryBuilder.addFields(largeAccountQuery, 'account_id');
      largeAccountQuery = ConseilQueryBuilder.addPredicate(largeAccountQuery, 'balance', ConseilOperator.GT, [9000000000]);
      largeAccountQuery = ConseilQueryBuilder.addPredicate(largeAccountQuery, 'account_id', ConseilOperator.STARTSWITH, ['tz']);
      largeAccountQuery = ConseilQueryBuilder.addPredicate(largeAccountQuery, 'account_id', ConseilOperator.IN, [originator, issuer], true);
      largeAccountQuery = ConseilQueryBuilder.setLimit(largeAccountQuery, 30);
      const largeAccountResult = await ConseilDataClient.executeEntityQuery(conseilServer, 'tezos', conseilServer.network, 'accounts', largeAccountQuery);
      const largeAccounts = largeAccountResult.map(a => a.account_id);
    </pre>
    <p>
      Now that we have this data, we can iterate through it, and use a TokenHelper method to transfer the token over to their accounts easily!
    </p>
    <pre>
      for (let i = 0; i < largeAccounts.length; i++) {
                                                                 //                                     fee     source                  destination       amount gas      freight
        groupid = await Tzip7ReferenceTokenHelper.transferBalance(tezosNode, keystore, contractAddress, 50_000, keystore.publicKeyHash, largeAccounts[i], 1_000, 125_000, 100);
        console.log(`balance transfer to "${largeAccounts[i]}"`);
      }
    </pre>
    <p>
      And we've done it! Let's repeat the steps for the 30 smallest accounts.
    </p>
    <pre>
      let smallAccountQuery = ConseilQueryBuilder.blankQuery();
      smallAccountQuery = ConseilQueryBuilder.addFields(smallAccountQuery, 'account_id');
      smallAccountQuery = ConseilQueryBuilder.addPredicate(smallAccountQuery, 'balance', ConseilOperator.LT, [9000000000]);
      smallAccountQuery = ConseilQueryBuilder.addPredicate(smallAccountQuery, 'balance', ConseilOperator.LT, [999000000]);
      smallAccountQuery = ConseilQueryBuilder.addPredicate(smallAccountQuery, 'account_id', ConseilOperator.STARTSWITH, ['tz']);
      smallAccountQuery = ConseilQueryBuilder.addPredicate(smallAccountQuery, 'account_id', ConseilOperator.IN, [originator, issuer], true);
      smallAccountQuery = ConseilQueryBuilder.setLimit(smallAccountQuery, 90);
      let smallAccountResult = await ConseilDataClient.executeEntityQuery(conseilServer, 'tezos', conseilServer.network, 'accounts', smallAccountQuery);
      const smallAccounts = smallAccountResult.map(a => a.account_id);
      console.log(smallAccounts.length);

      for (let i = 0; i < largeAccounts.length; i++) {
          for (let j = 3 * i, k = 3 * (i + 1); j < k; j++) {
              groupid = await Tzip7ReferenceTokenHelper.approveBalance(tezosNode, keystore, contractAddress, 50_000, smallAccounts[j], 100, 125_000, 100);
              console.log(`approve allowance for "${smallAccounts[j]}"`);
          }
      }

      console.log(`current supply: ${await Tzip7ReferenceTokenHelper.getTokenSupply(tezosNode, contractAddress)}`);
      console.log(`${issuer} balance: ${await Tzip7ReferenceTokenHelper.getAccountBalance(tezosNode, mapid, issuer)}`);
    </pre>
    <p>
      Those last two log statements let us find out how many tokens we put into circulation and our (the issuer's) remaining token balance. Isn't creating a currency fun!
    </p>
    <p>
      To look at the code in its entirety, checkout out this <a href="https://gist.github.com/anonymoussprocket/2df333da147b57510b1f78a9c930caab">gist</a> and the corresponding Medium <a href="https://medium.com/the-cryptonomic-aperiodical/tezos-is-now-an-asset-tokenization-platform-4d88ded4e9c">article</a>. Once again, feel free to reach out for any assistance whatsoever, and see our Documentation for a more in-depth look at the products used. Happy Hacking!
    </p>
    <h3><a name="tutorials-conseil">Analyzing blockchain data using Conseil</a></h3>
    <p>
      Visit the <a href="https://github.com/Cryptonomic/Conseil/wiki/Tutorial%3A-Querying-for-Tezos-data">tutorial</a> on the Conseil wiki.
    </p>
    <h3><a name="tutorials-conseiljs">Basic blockchain functions with ConseilJS</a></h3>
    <p>
      ConseilJS is the Cryptonomic one-stop solution for all of your Tezos needs. Using this web library, you can build powerful web apps and DApps that can leverage the full depth of the Tezos platform.
    </p>
    <p>
      Let’s start by querying some accounts.
    </p>
    <p>
      The following tutorial’s code is in web based JS. It can be entered in a script tag, or a standalone ‘.js’ file called from an HTML page. Instead of using Node, it has been imported using the following CDN link <a href="https://cryptonomic.github.io/ConseilJS/#/?id=use-with-web">here</a>. Just copy and paste it above where your JS is initialized like this:
    </p>
    <pre>
      &lt;script src="https://cdn.jsdelivr.net/gh/cryptonomic/conseiljs/dist-web/conseiljs.min.js" integrity="sha384-eSd4aru4A1k5ejohBE9T8uPo4P1TT6TTdnuO71HrrNr0pmZaF+C5/YQyYv0JNqhV" crossorigin="anonymous">&lt;/script>
    </pre>
    <p>
      Keep in mind that the “integrity” section changes with every update, so if your code doesn’t work, get the latest CDN from the link above.
    </p>
    <p>
      For a more robust installation of ConseilJS, you can see the instructions <a href="https://cryptonomic.github.io/ConseilJS/#/?id=use-with-nodejs">here</a> for your language of choice (TypeScript or JavaScript).
    </p>
    <p>
      We first need to visit <a href="https://nautilus.cloud/">Nautilus Cloud</a> in order to procure our ConseilJS API Keys and Tezos Node connection information for the appropriate Tezos Network (mainnet or testnet). If you’d rather host your own Tezos and <a href="https://github.com/Cryptonomic/Conseil/wiki">Conseil</a> node, you can do that too, but for simplicity, we recommend using our own hosted solutions.
    </p>
    <h4>Tutorial Setup:</h4>
    <p>
      We can initialize a connection to Conseil with our API Keys as follows:
    </p>
    <pre>
      const conseilServer = {
         url: 'https://conseil-prod.cryptonomic-infra.tech:443',
         apiKey: 'f86ab59d-d2ea-443b-98e2-6c0785e3de8c',
         network: 'mainnet'
      };
    </pre>
    <p>
      For the URL, put in the link to the Conseil Node. We can also make another constant to store the Tezos Node address, so let’s do that now as well.
    </p>
    <pre>
      const tezosNode = “https://tezos-prod.cryptonomic-infra.tech:443”
    </pre>
    <p>
      The ‘conseilServer’ object can now be used to authenticate different Conseil queries, while the ‘tezosNode’ will come in handy for many different on-chain operations.
    </p>
    <h4>Conseil Accounts Query:</h4>
    <p>
      Now, let’s use the ConseilQuery class to start querying for account balances. We start with a blank query:
    </p>
    <pre>
      let query = conseiljs.ConseilQueryBuilder.blankQuery();
    </pre>
    <p>
      Then, we add on the fields we want to be part of the result set, in this case, the “balance” of the accounts, and their “account_id.” We can add as many fields as we want here, given that they are valid fields, but for now, let’s keep it simple.
    </p>
    <pre>
      query = conseiljs.ConseilQueryBuilder.addFields(query, 'balance', 'account_id');
    </pre>
    <p>
      If we want a specific account, we can add a predicate too, which allows us to query by different conditional operators. This takes in a ConseilOperator enum that we use to send different parameters to the query.
    </p>
    <pre>
      query = conseiljs.ConseilQueryBuilder.addPredicate(query, 'account_id', conseiljs.ConseilOperator.EQ, ["tz1gfArv665EUkSg2ojMBzcbfwuPxAvqPvjo"]);
    </pre>
    <p>
      Here, we are mandating that the account ID of the query is equal to the address given, using ‘conseiljs.ConseilOperator.EQ’. Feel free to replace the address there with your own address! You can find more information about the different ConseilOperators <a href="https://cryptonomic.github.io/ConseilJS/#/?id=addpredicatequery-field-operation-values-invert-group">here</a>.
    </p>
    <p>
      If we leave this line out, we'd just get a bunch of accounts without any ordering. If we want ordered data, we need to specify which element(s) to order by, and whether it should be ascending or descending with the ConseilSortDirection enum.
    </p>
    <pre>
      query = conseiljs.ConseilQueryBuilder.addOrdering(query, "balance", conseiljs.ConseilSortDirection.DESC);
    </pre>
    <p>
      There is a default limit of 100 rows of output per query. However, this is easy to increase or decrease!
    </p>
    <pre>
      query = conseiljs.ConseilQueryBuilder.setLimit(query, 684);
    </pre>
    <p>
      Now we have a basic query set up for accounts and balances!
    </p>
    <pre>
      let query = conseiljs.ConseilQueryBuilder.blankQuery();
      query = conseiljs.ConseilQueryBuilder.addFields(query, 'balance');
      query = conseiljs.ConseilQueryBuilder.addFields(query, 'account_id');
      query = conseiljs.ConseilQueryBuilder.addOrdering(query, "balance", conseiljs.ConseilSortDirection.DESC);
      query = conseiljs.ConseilQueryBuilder.setLimit(query, 250);
    </pre>
    <p>
      We can now run this query using the ConseilDataClient, passing in the configuration from Nautilus Cloud, the “entity” that we want to query (in this case, “accounts”), and the query itself. Note that this is an asynchronous function, so it should be in its own async function, and will delay further execution until the query is loaded from the server.
    </p>
    <pre>
      result = await conseiljs.ConseilDataClient.executeEntityQuery(conseilServer, 'tezos', conseilServer.network, 'accounts', query);
    </pre>
    <p>
      In order to make this asynchronous function work, let’s make an async wrapper function for the executeEntityQuery function that will print the results, and return them as well.
    </p>
    <pre>
      let execute = async function(query, entity) {
          let result = await conseiljs.ConseilDataClient.executeEntityQuery(conseilServer, 'tezos', conseilServer.network, entity, query);
          console.log(result)
          return result
      }
    </pre>
    <p>
      The function returns an array of objects which we can then use for whatever purpose we dream of, such as graphing or running further operations. We can use this function to execute the query as follows:
    </p>
    <pre>
      result = execute(query, "accounts")
    </pre>
    <p>
      Let’s take a step back here to think about what we’re doing. Each operation performed is included in a block on the chain. ConseilJS uses the API provided by Nautilus Cloud to access data indexed by Conseil. The queries that we run are powered by Cryptonomic’s servers that index block data and convert the blockchain into more accessible relational database tables. If this were to be done without ConseilJS, we’d have to connect to a TezosNode directly using the tezos client, and manually define and run all of these operations. This greatly simplifies the Tezos development process!
    </p>
    <p>
      Accounts are one of many entities. If we want to see different operation details, or even block details, we can simply specify the entity that you want to query in executeEntityQuery and adjust your predicates accordingly (we’re querying the blocks entity next!)
    </p>
    <p>
      To see all of the different entities and predicates in action, check out Cryptonomic’s own data analytics engine, <a href="https://arronax.io/">Arronax</a>! This site acts as a powerful GUI for our Conseil Querying, and runs off of a Conseil and ConseilJS.
    </p>
    <p>
      The interface allows you to add fields, predicates, and even aggregations with ease. It works not only as a standalone querying tool, but also as a test board for making sure your queries work as intended before running them in ConseilJS.
    </p>
    <p>
      <a href="https://gist.github.com/PrathamRawat/ab16612268d2721911a88f5a8fabe98f">Here</a> is the complete Accounts Query code that you can play around with yourself!
    </p>
    <h4>
      Querying Bakers:
    </h4>
    <p>
      A common account operation is a delegation, which is essentially choosing a baker and offering them the stake from your tez in return for their baking rewards.
    </p>
    <p>
      This is the Tezos Liquid Proof of Stake (LPoS) model in action! Instead of a regular proof of stake model, where a user’s baking and voting rights come strictly from the amount of coin that they hold, the LPOS means that a user’s stake is liquid, allowing users to lend their stake to other bakers for a share of the baking profits.
    </p>
    <p>
      To query bakers that we might want to delegate to, we can query run another Conseil query. There are a number of ways to gauge a baker’s performance, such as their delegated balance (the higher results in a higher likelihood of baking a block), or the number of blocks that a baker has baked. Let’s work with the latter.
    </p>
    <p>
      The number of blocks a baker has baked is not a property of the “bakers” entity. Instead, we know the baker that baked each block, so we can run a simple query on the “blocks” entity to get our list of bakers.
    </p>
    <p>
      The first steps should be no puzzle by now, create a blank query, and add the fields we want. In this case, we want the block hash, which will act like a unique identifier for each block, and the baker that produced each block.
    </p>
    <pre>
      let query = conseiljs.ConseilQueryBuilder.blankQuery();
      query = conseiljs.ConseilQueryBuilder.addFields(query, 'baker');
      query = conseiljs.ConseilQueryBuilder.addFields(query, 'hash');
    </pre>
    <p>
      Then, we can add a predicate for all blocks produced after a certain date. This will make sure our baker data is recent and relevant! You don’t have to add a field to a query if you want it to be in a predicate, so we don’t need to include the timestamp data as a field.
    </p>
    <pre>
      query = conseiljs.ConseilQueryBuilder.addPredicate(query, 'timestamp', conseiljs.ConseilOperator.AFTER, [date]);
    </pre>
    <p>
      Now we can add a new element to the query: the aggregation function. This allows us to aggregate data per unique element in the table: in this case, the block hash. We can set up a counting aggregation function, and apply it to the block hashes. As a result, the query will count all of the block hashes per baker, and create a new row, titled “count_hash.”
    </p>
    <pre>
      query = conseiljs.ConseilQueryBuilder.addAggregationFunction(query, "hash", conseiljs.ConseilFunction.count);
    </pre>
    <p>
      The new row that we have should be sorted, so that we can easily find the baker with the most blocks. So we can add a quick ordering to the “count_hash” table. And finally set a limit of 20, so our data is quickly queried and downloaded.
    </p>
    <pre>
      query = conseiljs.ConseilQueryBuilder.addOrdering(query, "count_hash", conseiljs.ConseilSortDirection.DESC);
      query = conseiljs.ConseilQueryBuilder.setLimit(query, 20);
    </pre>
    <p>
      Now that we have the query set up, one more familiar line should run it for us. Remember, we’re querying the “blocks” entity, not bakers!
    </p>
    <pre>
      const result = await conseiljs.ConseilDataClient.executeEntityQuery(
          conseilServer,
          'tezos',
          conseilServer.network,
          'blocks',
          query
      );
    </pre>
    <p>
      We can also call this in our wrapper function that we defined earlier:
    </p>
    <pre>
      result = execute(query, "blocks")
    </pre>
    <p>
      The output is once again an array of objects:
    </p>
    <pre>
      [{count_hash: "5015", baker: "tz1irJKkXS2DBWkU1NnmFQx1c1L7pbGg4yhk"},
      {count_hash: "2268", baker: "tz1gfArv665EUkSg2ojMBzcbfwuPxAvqPvjo"},
      {count_hash: "2170", baker: "tz2TSvNTh2epDMhZHrw73nV9piBX7kLZ9K9m"},
      {count_hash: "1939", baker: "tz1S8MNvuFEUsWgjHvi3AxibRBf388NhT1q2"},
      {count_hash: "1726", baker: "tz3NExpXn9aPNZPorRE4SdjJ2RGrfbJgMAaV"}]
    </pre>
    <p>
      You can find the complete baker query <a href="https://gist.github.com/PrathamRawat/cb40f54127e44acd506681de9aacaca3">here</a>!
    </p>
    <p>
      Before we can delegate our stake though, we need to initialize some accounts.
    </p>
    <h4>
      Account Creation Operations:
    </h4>
    <p>
      These queries can be used for their own standalone data analysis, or they can be used as the foundations for powerful dapps that interact with the chain and submit different operations. This makes coding a custom wallet app, multipurpose querying and transaction tool, or even your own GUI to a deployed smart contract is much easier with the ConseilJS interface.
    </p>
    <p>
      The foundations of all of these queries are account operations, such as transferring tez or delegating. If we want to run account operations of our own, we need to set up and activate our own account. Let’s use the <a href="https://faucet.tzalpha.net/">Testnet Faucet</a> to get loaded with some XTZ. ConseilJS makes it simple to set up the account (remember to update the keys and URL in the conseilServer object from Mainnet to Testnet!)
    </p>
    <pre>
      const conseilServer = {
         url: 'https://conseil-dev.cryptonomic-infra.tech:443',
         apiKey: <apikey>,
         network: 'carthagenet'
      };
    </pre>
    <p>
      We can copy the JSON file we get from the Faucet into our application, and send it to the TezosWalletUtil, using the unlockFundraiserIdentity() function.
    </p>
    <pre>
      const keystore = await TezosWalletUtil.unlockFundraiserIdentity(
           faucetAccount.mnemonic.join(' '),
           faucetAccount.email,
           faucetAccount.password,
           faucetAccount.pkh
      );
    </pre>
    <p>
      This returns a keystore object, which contains our public and private key pair that we can use to authenticate many of the different operations we might want to accomplish. But not yet!
    </p>
    <p>
      After this is done, we need to pass the keystore to another function to activate the account. The TezosNodeWriter can send an activation operation with the keys generated by the Wallet Util. This claims the associated account and allows us to use it and the tez that it stores, and is necessary because these testnet accounts mimic the original Tezos fundraiser accounts, where activation served as a security measure for protecting people’s funds.
    </p>
    <pre>
      const result = await TezosNodeWriter.sendIdentityActivationOperation(
          tezosNode,
          keystore,
          faucetaccount.secret
      );
    </pre>
    <p>
      We have one more step until we’re good to go! The account revelation “reveals” the account by publishing its public key on the blockchain, allowing other accounts to confirm transactions signed by our account’s public key. It’s another method of the TezosNodeWriter.
    </p>
    <pre>
      const revelationResult = await TezosNodeWriter.sendKeyRevealOperation(tezosNode, keystore);
    </pre>
    <p>
      The full code for activating testnet accounts downloaded from the faucet can be found <a href="https://gist.github.com/PrathamRawat/348e7c2acdfb14b3bcdae8923df9b203">here</a>!
    </p>
    <p>
      If you need to work on transactions with real XTZ, ConseilJS can easily create and manage mainnet accounts for you! The process for creating a keystore for a mainnet account is just as simple.
    </p>
    <p>
      First, we use the TezosWalletUtil function to generate a mnemonic, which is the random assortment of letters you might remember from the faucet. We can use these letters to activate an account, with the TezosWalletUtil’s unlockIdentityWithMnemonic() function.
    </p>
    <pre>
      const mnemonic = TezosWalletUtil.generateMnemonic();
      const keystore = await TezosWalletUtil.unlockIdentityWithMnemonic(mnemonic, '');
    </pre>
    <p>
      It’s a good idea to log each of these so your users (or you!) can note these down just in case.
    </p>
    <p>
      The next step is to reveal the account, the same way that we revealed the faucet generated account. While we don’t have to activate it this time, because this is a brand new account it will be empty, so before we can do anything, we would need to make sure the account has funds. So if you’re just playing around, we recommend using a faucet account for simplicity. Keeping the keys handy, we can now do things like transfer tez, or delegate! So let’s do that.
    </p>
    <h4>Account Delegation Operation:</h4>
    <p>
      Let’s delegate to the baker with the most blocks baked, back from the query we had run on bakers. Thanks to the ordering we had applied, the baker with the most bloks is the first object in the list returned to us. Putting all of the tools we’ve learned together, this becomes quite simple using another method of the TezosNodeWriter class.
    </p>
    <pre>
      const result = await conseiljs.TezosNodeWriter.sendDelegationOperation(
          tezosNode,
          keystore,
          keystore.publicKeyHash,
          result[0].baker,
          10000
      );
    </pre>
    <p>
      Now all that’s left is to wait for the pay period and collect our fresh tez!
    </p>
    <p>
      The full code, with testnet account activation, the original baker query, and testnet delegation can be found <a href="https://gist.github.com/PrathamRawat/846bc9d56975b8196d66f879fa299d1a">here</a>!
    </p>
    <h4>
      Account Transaction Operation:
    </h4>
    <p>
      In order to transfer, you’ll need the keystore of your own account, and the account ID of another account. If you’re on testnet and need an account, just pick one off from Arronax’s testnet <a href="https://arronax.io/tezos/carthagenet/accounts">accounts page</a>.
    </p>
    <p>
      From there, transferring funds is really quite simple. The TezosNodeWriter has a sendTransactionOperation() which greatly simplifies the operation. Keep in mind that the amount and fee are measured in micro-tez (µꜩ) .
    </p>
    <pre>
      const result = await TezosNodeWriter.sendTransactionOperation(
          tezosNode,
          keystore,
          ‘Account ID’,
          amount,
          fee,
          ''”
      );

      console.log(`Injected operation group id ${result.operationGroupID}`);
    </pre>
    <p>
      This operation, and all of the other operations we’ve done, is stored in the “result” variable, which contains a few operation details. Unfortunately, Tezos testnet currently has a problem with returning the operation ID. In order to counter this, we have a function that accepts the ID as an input, and returns the proper ID.
    </p>
    <pre>
      function clearRPCOperationGroupHash(hash) {
          return hash.replace(/\"/g, '').replace(/\n/, '');
      }
    </pre>
    <p>
      You can get the correct group ID as follows:
    </p>
    <pre>
      result.operationGroupID = clearRPCOperationGroupHash(result.operationGroupID)
    </pre>
    <p>
      Now that we have the operation ID stored, say we want the gas that the transaction consumed, and its cycle. Let’s start with a blank query.
    </p>
    <pre>
      let query = conseiljs.ConseilQueryBuilder.blankQuery();
    </pre>
    <p>
      And then add the “operation_group_hash”, the “gas_consumed”, and the “cycle” as fields.
    </p>
      <pre>
        query = conseiljs.ConseilQueryBuilder.addFields(
            query,
            ‘operation_group_hash',
            ‘gas_consumed’,
            ‘cycle’
        );
    </pre>
    <p>
      Then, just as we did with the account information query, we can add a predicate to the operation ID, that it must equal the ID returned by our transaction, so we get the details specific to that operation.
    </p>
    <pre>
      query = conseiljs.ConseilQueryBuilder.addPredicate(
          query,
          ‘operation_group_hash’,
          conseiljs.ConseilOperator.EQ,
          [result.operationGroupID]
      );
    </pre>
    <p>
      Running this query against the “operations” entity will give us an object with the cycle and consumed gas for our operation.
    </p>
    <pre>
      const result = await conseiljs.ConseilDataClient.executeEntityQuery(
          conseilServer,
          'tezos',
          conseilServer.network,
          'operations',
          query
      );
    </pre>
    <p>
      For the whole transaction code, check <a href="https://gist.github.com/PrathamRawat/9519c172a009b6511c2b8c673c1bac78">this</a> out!
    </p>
    <p>
      That’s all for a quick welcome tour of ConseilJS! If you need help, please feel free to reach out to us via email, or our Riot channels. For more documentation of ConseilJS, check out our docs page <a href="https://cryptonomic.github.io/ConseilJS/#">here</a>. Good luck!
    </p>
    <h3><a name="tutorials-bakerregistry">Interacting with the Tezos baker registry</a></h3>
    <p>
      Coming soon...
    </p>
    <hr/>
    




    <h2><a name="documentation">More Documentation</a></h2>

    <p>Coming very soon!</p>
    
  </body>
</html>
